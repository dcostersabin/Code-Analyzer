import timeit
from ModuleChecker import ModuleChecker
import os
import io
import pandas as pd
import tracemalloc
from os import path
import shutil

__REPEAT__ = 5
__NUMBER__ = 1000


class Benchmark:
    """
    Benchmarking python codes
    Completeness
    Correctness
    Time Complexity
    Peak Memory Usages
    Detailed Function Profiling
    """

    def __init__(self, url, expected_output, params):
        """
        :param url:  Url To Be Cloned or Github repository HTTPS Link SSH Is Not Supported
        :param expected_output: Actual output generated by the algorithm
        :param params: Parameters For Function Testing
        """
        self.url = url
        self.repo_validity = ModuleChecker(self.url).clone_check()
        self.benchmark_score = {"complete": False, "correctness": True, "time": None, "memory": None,
                                "detailed_profiling": None}
        self.target_output = expected_output
        self.calculated_output = None
        self.params = params

    def start(self):
        """
        :return: False if the given repository link is not valid otherwise returns the defined complexities score
        """
        if self.repo_validity:
            self.__completeness__()
            self.remove_temp()
            return self.benchmark_score
        else:
            self.remove_temp()
            return False

    def __time_complexity__(self):
        """
        Measures the time taken by the code to execute for __REPEAT__ times
        :return: None
        """
        params = self.params
        setup_code = "from temp.test import Testing"
        stmt_code = "Testing.setup(" + str(params) + ")"
        time = timeit.repeat(stmt=stmt_code, setup=setup_code, repeat=__REPEAT__, number=__NUMBER__)
        self.benchmark_score['time'] = time

    def __space_complexity__(self):
        """
        Measures the peak memory used by the defined function
        :return: None
        """
        from temp.test import Testing
        tracemalloc.start()
        Testing.setup(self.params)
        current, peak = tracemalloc.get_traced_memory()
        tracemalloc.stop()
        self.benchmark_score['memory'] = peak / 10 ** 6

    def __completeness__(self):
        """
        Checks if the given module provides any output or not
        :return: None
        """
        from temp.test import Testing
        result = Testing.setup(self.params)
        if result is not None:
            self.benchmark_score["complete"] = True
            try:
                assert result == self.target_output
                self.benchmark_score["correctness"] = True
                self.__time_complexity__()
                self.__detailed_profiling__()
                self.__space_complexity__()
            except AssertionError:
                self.benchmark_score["correctness"] = False

    def __test__(self):
        """
        Testing the downloaded module
        :return: None
        """
        from temp.test import Testing
        a = Testing.setup(self.params)

    def __detailed_profiling__(self):
        """
        Using cProfile to aggregate the resources used by the function
        :return: None
        """
        import cProfile, pstats
        profiler = cProfile.Profile()
        profiler.enable()
        self.__test__()
        profiler.disable()
        stream = io.StringIO()
        pstats.Stats(profiler, stream=stream).sort_stats('ncalls').strip_dirs().print_stats()
        stream = stream.getvalue()
        self.__convert_to_csv__(stream)
        self.benchmark_score['detailed_profiling'] = pd.read_csv(os.getcwd() + '/temp/stat.csv')

    @staticmethod
    def __convert_to_csv__(stream):
        """
        Converting crpofile output to csv
        :param stream: IOStram for the cprofile output
        :return: None
        """
        result = 'ncalls' + stream.split('ncalls')[-1]
        result = '\n'.join([','.join(line.rstrip().split(None, 5)) for line in result.split('\n')])
        f = open(os.getcwd() + '/temp/stat'.rsplit('.')[0] + '.csv', 'w')
        f.write(result)
        f.close()

    def remove_temp(self):
        """
        Removes the temporary files after results are calculated
        :return: None
        """
        if path.exists(os.getcwd() + '/temp/'):
            shutil.rmtree(os.getcwd() + '/temp/')


